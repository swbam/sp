#!/usr/bin/env node

/**
 * Performance Monitoring Script for MySetlist
 * Continuously monitors and reports on key performance metrics
 * Generated by Sub-Agent 7 - Performance Measurement Agent
 */

import { performance } from 'perf_hooks';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const BASE_URL = 'http://localhost:3004';
const MONITORING_INTERVAL = 30000; // 30 seconds
const ALERT_THRESHOLDS = {
  apiResponseTime: 500,
  pageLoadTime: 2000,
  memoryIncrease: 50 * 1024 * 1024, // 50MB
  errorRate: 0.05 // 5%
};

let monitoringData = {
  startTime: Date.now(),
  metrics: [],
  alerts: [],
  summary: {
    totalRequests: 0,
    successfulRequests: 0,
    failedRequests: 0,
    averageResponseTime: 0,
    peakResponseTime: 0,
    memoryUsage: []
  }
};

console.log('üîç MySetlist Performance Monitoring Started');
console.log('============================================');
console.log(`Base URL: ${BASE_URL}`);
console.log(`Monitoring Interval: ${MONITORING_INTERVAL / 1000}s`);
console.log(`Alert Thresholds: ${JSON.stringify(ALERT_THRESHOLDS, null, 2)}`);

// Performance monitoring functions
class PerformanceMonitor {
  constructor() {
    this.baselineMemory = process.memoryUsage();
    this.requestHistory = [];
    this.errorHistory = [];
  }

  async monitorAPIEndpoints() {
    const endpoints = [
      { name: 'Trending', url: '/api/trending', critical: true },
      { name: 'Shows', url: '/api/shows', critical: true },
      { name: 'Search', url: '/api/search/artists?q=test', critical: true },
      { name: 'Artist', url: '/api/artists/taylor-swift', critical: false },
      { name: 'Stats', url: '/api/stats', critical: false }
    ];

    const results = [];
    
    for (const endpoint of endpoints) {
      const start = performance.now();
      
      try {
        const response = await fetch(`${BASE_URL}${endpoint.url}`);
        const responseTime = performance.now() - start;
        
        let data;
        try {
          data = await response.json();
        } catch (e) {
          data = null;
        }
        
        const result = {
          endpoint: endpoint.name,
          url: endpoint.url,
          responseTime,
          status: response.status,
          success: response.ok,
          critical: endpoint.critical,
          timestamp: new Date().toISOString(),
          dataValid: data !== null
        };
        
        results.push(result);
        
        // Check for alerts
        if (responseTime > ALERT_THRESHOLDS.apiResponseTime) {
          this.triggerAlert('SLOW_API_RESPONSE', `${endpoint.name} API took ${responseTime.toFixed(2)}ms`);
        }
        
        if (!response.ok && endpoint.critical) {
          this.triggerAlert('CRITICAL_API_ERROR', `${endpoint.name} API returned ${response.status}`);
        }
        
      } catch (error) {
        const responseTime = performance.now() - start;
        const result = {
          endpoint: endpoint.name,
          url: endpoint.url,
          responseTime,
          status: 'ERROR',
          success: false,
          critical: endpoint.critical,
          timestamp: new Date().toISOString(),
          error: error.message
        };
        
        results.push(result);
        
        if (endpoint.critical) {
          this.triggerAlert('CRITICAL_API_FAILURE', `${endpoint.name} API failed: ${error.message}`);
        }
      }
    }
    
    return results;
  }

  async monitorPageLoad() {
    const pages = [
      { name: 'Homepage', url: '/', critical: true },
      { name: 'Search', url: '/search', critical: true },
      { name: 'Shows', url: '/shows', critical: true },
      { name: 'Trending', url: '/trending', critical: false }
    ];

    const results = [];
    
    for (const page of pages) {
      const start = performance.now();
      
      try {
        const response = await fetch(`${BASE_URL}${page.url}`);
        const html = await response.text();
        const loadTime = performance.now() - start;
        
        const result = {
          page: page.name,
          url: page.url,
          loadTime,
          status: response.status,
          success: response.ok,
          critical: page.critical,
          timestamp: new Date().toISOString(),
          contentLength: html.length,
          hasContent: html.includes('<!DOCTYPE html>')
        };
        
        results.push(result);
        
        // Check for alerts
        if (loadTime > ALERT_THRESHOLDS.pageLoadTime) {
          this.triggerAlert('SLOW_PAGE_LOAD', `${page.name} page took ${loadTime.toFixed(2)}ms`);
        }
        
        if (!response.ok && page.critical) {
          this.triggerAlert('CRITICAL_PAGE_ERROR', `${page.name} page returned ${response.status}`);
        }
        
      } catch (error) {
        const loadTime = performance.now() - start;
        const result = {
          page: page.name,
          url: page.url,
          loadTime,
          status: 'ERROR',
          success: false,
          critical: page.critical,
          timestamp: new Date().toISOString(),
          error: error.message
        };
        
        results.push(result);
        
        if (page.critical) {
          this.triggerAlert('CRITICAL_PAGE_FAILURE', `${page.name} page failed: ${error.message}`);
        }
      }
    }
    
    return results;
  }

  monitorMemoryUsage() {
    const current = process.memoryUsage();
    const baseline = this.baselineMemory;
    
    const memoryDelta = {
      rss: current.rss - baseline.rss,
      heapUsed: current.heapUsed - baseline.heapUsed,
      heapTotal: current.heapTotal - baseline.heapTotal,
      external: current.external - baseline.external
    };
    
    const result = {
      current,
      baseline,
      delta: memoryDelta,
      timestamp: new Date().toISOString()
    };
    
    // Check for memory alerts
    if (memoryDelta.heapUsed > ALERT_THRESHOLDS.memoryIncrease) {
      this.triggerAlert('HIGH_MEMORY_USAGE', `Memory usage increased by ${(memoryDelta.heapUsed / 1024 / 1024).toFixed(2)}MB`);
    }
    
    return result;
  }

  triggerAlert(type, message) {
    const alert = {
      type,
      message,
      timestamp: new Date().toISOString(),
      severity: type.includes('CRITICAL') ? 'CRITICAL' : 'WARNING'
    };
    
    monitoringData.alerts.push(alert);
    
    // Console alert
    const icon = alert.severity === 'CRITICAL' ? 'üö®' : '‚ö†Ô∏è';
    console.log(`${icon} ALERT [${alert.type}]: ${alert.message}`);
    
    // Keep only last 50 alerts
    if (monitoringData.alerts.length > 50) {
      monitoringData.alerts = monitoringData.alerts.slice(-50);
    }
  }

  calculateMetrics(apiResults, pageResults, memoryResult) {
    const allRequests = [...apiResults, ...pageResults];
    const successfulRequests = allRequests.filter(r => r.success);
    const failedRequests = allRequests.filter(r => !r.success);
    
    const averageResponseTime = allRequests.length > 0 
      ? allRequests.reduce((sum, r) => sum + (r.responseTime || r.loadTime), 0) / allRequests.length 
      : 0;
    
    const peakResponseTime = allRequests.length > 0
      ? Math.max(...allRequests.map(r => r.responseTime || r.loadTime))
      : 0;
    
    const errorRate = allRequests.length > 0 
      ? failedRequests.length / allRequests.length 
      : 0;
    
    // Check error rate alert
    if (errorRate > ALERT_THRESHOLDS.errorRate) {
      this.triggerAlert('HIGH_ERROR_RATE', `Error rate is ${(errorRate * 100).toFixed(1)}%`);
    }
    
    const metrics = {
      timestamp: new Date().toISOString(),
      totalRequests: allRequests.length,
      successfulRequests: successfulRequests.length,
      failedRequests: failedRequests.length,
      averageResponseTime,
      peakResponseTime,
      errorRate,
      memoryUsage: memoryResult.current,
      memoryDelta: memoryResult.delta,
      apiResults,
      pageResults
    };
    
    return metrics;
  }

  displayMetrics(metrics) {
    console.log('\nüìä Performance Metrics Report');
    console.log('==============================');
    console.log(`Timestamp: ${metrics.timestamp}`);
    console.log(`Total Requests: ${metrics.totalRequests}`);
    console.log(`Success Rate: ${((metrics.successfulRequests / metrics.totalRequests) * 100).toFixed(1)}%`);
    console.log(`Average Response Time: ${metrics.averageResponseTime.toFixed(2)}ms`);
    console.log(`Peak Response Time: ${metrics.peakResponseTime.toFixed(2)}ms`);
    console.log(`Error Rate: ${(metrics.errorRate * 100).toFixed(1)}%`);
    console.log(`Memory Usage: ${(metrics.memoryUsage.heapUsed / 1024 / 1024).toFixed(2)}MB`);
    console.log(`Memory Delta: ${(metrics.memoryDelta.heapUsed / 1024 / 1024).toFixed(2)}MB`);
    
    // API Results
    console.log('\nüîå API Performance:');
    metrics.apiResults.forEach(api => {
      const status = api.success ? '‚úÖ' : '‚ùå';
      const critical = api.critical ? 'üö®' : '';
      console.log(`   ${status} ${critical} ${api.endpoint}: ${api.responseTime.toFixed(2)}ms (${api.status})`);
    });
    
    // Page Results
    console.log('\nüìÑ Page Performance:');
    metrics.pageResults.forEach(page => {
      const status = page.success ? '‚úÖ' : '‚ùå';
      const critical = page.critical ? 'üö®' : '';
      console.log(`   ${status} ${critical} ${page.page}: ${page.loadTime.toFixed(2)}ms (${page.status})`);
    });
    
    // Recent Alerts
    const recentAlerts = monitoringData.alerts.slice(-5);
    if (recentAlerts.length > 0) {
      console.log('\nüö® Recent Alerts:');
      recentAlerts.forEach(alert => {
        const icon = alert.severity === 'CRITICAL' ? 'üö®' : '‚ö†Ô∏è';
        console.log(`   ${icon} ${alert.type}: ${alert.message}`);
      });
    }
  }

  async saveMetrics() {
    const reportsDir = path.join(__dirname, 'reports');
    if (!fs.existsSync(reportsDir)) {
      fs.mkdirSync(reportsDir, { recursive: true });
    }
    
    const filename = `performance-monitoring-${new Date().toISOString().split('T')[0]}.json`;
    const filepath = path.join(reportsDir, filename);
    
    try {
      fs.writeFileSync(filepath, JSON.stringify(monitoringData, null, 2));
      console.log(`üìÑ Metrics saved to: ${filepath}`);
    } catch (error) {
      console.error('‚ùå Failed to save metrics:', error.message);
    }
  }

  generateSummaryReport() {
    const allMetrics = monitoringData.metrics;
    if (allMetrics.length === 0) return;
    
    const totalRequests = allMetrics.reduce((sum, m) => sum + m.totalRequests, 0);
    const totalSuccessful = allMetrics.reduce((sum, m) => sum + m.successfulRequests, 0);
    const totalFailed = allMetrics.reduce((sum, m) => sum + m.failedRequests, 0);
    
    const avgResponseTime = allMetrics.reduce((sum, m) => sum + m.averageResponseTime, 0) / allMetrics.length;
    const peakResponseTime = Math.max(...allMetrics.map(m => m.peakResponseTime));
    
    const criticalAlerts = monitoringData.alerts.filter(a => a.severity === 'CRITICAL').length;
    const warningAlerts = monitoringData.alerts.filter(a => a.severity === 'WARNING').length;
    
    console.log('\nüìã Session Summary Report');
    console.log('==========================');
    console.log(`Monitoring Duration: ${((Date.now() - monitoringData.startTime) / 60000).toFixed(1)} minutes`);
    console.log(`Total Requests: ${totalRequests}`);
    console.log(`Success Rate: ${((totalSuccessful / totalRequests) * 100).toFixed(1)}%`);
    console.log(`Average Response Time: ${avgResponseTime.toFixed(2)}ms`);
    console.log(`Peak Response Time: ${peakResponseTime.toFixed(2)}ms`);
    console.log(`Critical Alerts: ${criticalAlerts}`);
    console.log(`Warning Alerts: ${warningAlerts}`);
    
    const overallHealth = criticalAlerts === 0 && warningAlerts < 5 ? 'HEALTHY' : 'DEGRADED';
    console.log(`Overall Health: ${overallHealth === 'HEALTHY' ? '‚úÖ' : '‚ö†Ô∏è'} ${overallHealth}`);
  }
}

// Main monitoring loop
async function startMonitoring() {
  const monitor = new PerformanceMonitor();
  
  console.log('üîÑ Starting performance monitoring...\n');
  
  const monitoringLoop = async () => {
    try {
      // Monitor API endpoints
      const apiResults = await monitor.monitorAPIEndpoints();
      
      // Monitor page load times
      const pageResults = await monitor.monitorPageLoad();
      
      // Monitor memory usage
      const memoryResult = monitor.monitorMemoryUsage();
      
      // Calculate metrics
      const metrics = monitor.calculateMetrics(apiResults, pageResults, memoryResult);
      
      // Store metrics
      monitoringData.metrics.push(metrics);
      
      // Keep only last 100 metrics
      if (monitoringData.metrics.length > 100) {
        monitoringData.metrics = monitoringData.metrics.slice(-100);
      }
      
      // Display metrics
      monitor.displayMetrics(metrics);
      
      // Save metrics periodically
      if (monitoringData.metrics.length % 10 === 0) {
        await monitor.saveMetrics();
      }
      
    } catch (error) {
      console.error('‚ùå Monitoring error:', error.message);
    }
  };
  
  // Initial run
  await monitoringLoop();
  
  // Start monitoring interval
  const intervalId = setInterval(monitoringLoop, MONITORING_INTERVAL);
  
  // Graceful shutdown
  process.on('SIGINT', () => {
    console.log('\nüõë Shutting down monitoring...');
    clearInterval(intervalId);
    
    monitor.generateSummaryReport();
    monitor.saveMetrics();
    
    console.log('\nüëã Monitoring stopped');
    process.exit(0);
  });
  
  console.log(`üîÑ Monitoring running... (Press Ctrl+C to stop)`);
}

// Health check function
async function healthCheck() {
  console.log('üè• Running health check...');
  
  const healthEndpoints = [
    { name: 'Homepage', url: '/' },
    { name: 'API Health', url: '/api/trending' }
  ];
  
  for (const endpoint of healthEndpoints) {
    try {
      const start = performance.now();
      const response = await fetch(`${BASE_URL}${endpoint.url}`);
      const responseTime = performance.now() - start;
      
      const status = response.ok ? '‚úÖ HEALTHY' : '‚ùå UNHEALTHY';
      console.log(`   ${status} ${endpoint.name}: ${responseTime.toFixed(2)}ms (${response.status})`);
      
    } catch (error) {
      console.log(`   ‚ùå FAILED ${endpoint.name}: ${error.message}`);
    }
  }
}

// Command line interface
const command = process.argv[2];

switch (command) {
  case 'monitor':
    startMonitoring();
    break;
  case 'health':
    healthCheck();
    break;
  default:
    console.log('Usage: node performance-monitoring-script.mjs [monitor|health]');
    console.log('  monitor: Start continuous performance monitoring');
    console.log('  health:  Run one-time health check');
    process.exit(1);
}